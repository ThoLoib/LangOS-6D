import numpy as np
from scipy.spatial.transform import Rotation as R

# -------------------------------------------------------------------
# Estimated poses (your model output, quaternions + translations in m)
# -------------------------------------------------------------------
EST_POSES = {

    'sugar': {
        'q': np.array([0.12953522392135852, 0.41803495123954737,
                       -0.6322152531863405, 0.6393521765767936]),  # (x,y,z,w)
        't': np.array([0.018365224823355675, -0.011889229528605938, 0.7604914903640747])
    },
    'bowl': {
        'q': np.array([-0.19693794904078032, 0.96735276703721,
                       -0.023342007836066315, -0.15779489716324985]),
        't': np.array([0.039592940360307693, 0.03624336048960686, 0.897311270236969])
    },
    'spam': {
        'q': np.array([0.13578315848760159, 0.2564757715766081,
                       -0.6532746249649147, 0.6992963912282657]),
        't': np.array([-0.013157911598682404, -0.014992274343967438, 0.24004028737545013])
    },
    'tuna': {
        'q': np.array([-0.01587167138374903, 0.011613478563050783,
                       0.9773060600032963, 0.21091737877181002]),
        't': np.array([0.022842256352305412, -0.014549489133059978, 0.1451200246810913])
    }
}

# Reconstructed 
# {
#     'sugar': {
#         'q': np.array([-0.515774115971046, 0.6321775059999027, 
#                        -0.32392276789993224, 0.4789601379224792]),  # (x, y, z, w)
#         't': np.array([0.030952302739024162, -0.021439945325255394, 2.402466297149658])  # translation from TWO
#     },
#     'bowl': {
#         'q': np.array([0.08949280080740903, -0.1736745407959604, 
#                        0.9113968101809158, -0.36219347936223834]),
#         't': np.array([0.09481263160705566, 0.12053795158863068, 2.887852907180786])
#     },
#     'spam': {
#         'q': np.array([-0.3212370210697728, -0.2528595847783339, 
#                        0.7835748128228615, -0.4678454178041506]),
#         't': np.array([-0.3116810917854309, -0.3054714798927307, 4.10290002822876])
#     },
#     'tuna': {
#         'q': np.array([0.37651351272838357, 0.15812276727819133, 
#                        -0.6457315099440321, 0.6451864178266081]),
#         't': np.array([0.8770861029624939, -0.5648736357688904, 5.618049144744873])
#     }
# }


# GT
#{
#    'bowl': {
#        'q': np.array([-0.3614970753919051, 0.2033469576407172,
#                       0.31660477532505665, 0.8530716690749022]),  # (x,y,z,w)
#        't': np.array([0.024621620774269104, 0.02009507454931736, 0.8393784761428833])
#    },
#    'tuna': {
#        'q': np.array([-0.36083605895207616, -0.2342441104784914,
#                       -0.5897819077100945, 0.6834357147101905]),
#        't': np.array([0.15078119933605194, -0.0952930599451065, 0.9664980173110962])
#    },
#    'sugar': {
#        'q': np.array([0.657165078097183, 0.6313499698652497,
#                       0.11792376652220124, -0.39449375463851477]),
#        't': np.array([0.017460158094763756, -0.006102674175053835, 0.7963466644287109])
#    },
#    'spam': {
#        'q': np.array([0.431846478449648, 0.41612876922188397,
#                       0.5736566896583789, 0.557909827450943]),
#        't': np.array([-0.0446477010846138, -0.050440289080142975, 0.7174946665763855])
#    }
#}




 #### OSCAR
#{
#    'sugar': {
#        'q': np.array([0.12953522392135852, 0.41803495123954737,
#                       -0.6322152531863405, 0.6393521765767936]),  # (x,y,z,w)
#        't': np.array([0.018365224823355675, -0.011889229528605938, 0.7604914903640747])
#    },
#    'bowl': {
#        'q': np.array([-0.19693794904078032, 0.96735276703721,
#                       -0.023342007836066315, -0.15779489716324985]),
#        't': np.array([0.039592940360307693, 0.03624336048960686, 0.897311270236969])
#    },
#    'spam': {
#        'q': np.array([0.13578315848760159, 0.2564757715766081,
#                       -0.6532746249649147, 0.6992963912282657]),
#        't': np.array([-0.013157911598682404, -0.014992274343967438, 0.24004028737545013])
#    },
#    'tuna': {
#        'q': np.array([-0.01587167138374903, 0.011613478563050783,
#                       0.9773060600032963, 0.21091737877181002]),
#        't': np.array([0.022842256352305412, -0.014549489133059978, 0.1451200246810913])
#    }
#}
#
## -------------------------------------------------------------------
## Ground truth poses (R in row-major, t in mm)
# -------------------------------------------------------------------
GT_POSES = {
    'sugar': {
        'R': np.array([-0.09398, 0.94024, 0.32728,
                       -0.69155, 0.17483, -0.70085,
                       -0.71619, -0.29220, 0.63379]).reshape(3, 3),
        't': np.array([18.5899, -10.1444, 780.6027]) / 1000.0  # convert to m
    },
    'tuna': {
        'R': np.array([0.64188, 0.75828, 0.11404,
                       -0.55864, 0.36056, 0.74694,
                       0.52527, -0.54315, 0.65504]).reshape(3, 3),
        't': np.array([148.5639, -98.4664, 937.2247]) / 1000.0
    },
    'spam': {
        'R': np.array([-0.80095, -0.58462, -0.12922,
                       -0.32510, 0.60589, -0.72609,
                       0.50278, -0.53955, -0.67535]).reshape(3, 3),
        't': np.array([-63.6572, -63.8974, 901.6481]) / 1000.0
    },
    'bowl': {
        'R': np.array([-0.82609, 0.54925, 0.12609,
                       -0.26685, -0.57833, 0.77093,
                       0.49636, 0.60321, 0.62432]).reshape(3, 3),
        't': np.array([26.6412, 19.5885, 814.4062]) / 1000.0
    }
}

# -------------------------------------------------------------------
# Symmetry handling
# -------------------------------------------------------------------
def get_symmetry_transforms(label):
    if label in ['bowl', 'tuna']:
        # continuous symmetry around z-axis (sampled every 2 degrees)
        rots = []
        for deg in range(0, 360, 2):
            Rz = R.from_euler('z', deg, degrees=True).as_matrix()
            rots.append(Rz)
        return rots
    else:
        # symmetric under 180° flips around x, y, z
        Rx = R.from_euler('x', 180, degrees=True).as_matrix()
        Ry = R.from_euler('y', 180, degrees=True).as_matrix()
        Rz = R.from_euler('z', 180, degrees=True).as_matrix()
        return [np.eye(3), Rx, Ry, Rz]

def rotation_error(R_est, R_gt, label):
    # apply symmetry transforms to GT
    min_err = 1e9
    for S in get_symmetry_transforms(label):
        R_sym = S @ R_gt
        R_rel = R_est @ R_sym.T
        angle = np.arccos(np.clip((np.trace(R_rel) - 1) / 2, -1, 1))
        err_deg = np.degrees(angle)
        if err_deg < min_err:
            min_err = err_deg
    return min_err

# -------------------------------------------------------------------
# Main evaluation
# -------------------------------------------------------------------
results = {}
for label, est in EST_POSES.items():
    # Estimated rotation
    R_est = R.from_quat(est['q']).as_matrix()
    t_est = est['t']

    # Ground truth
    R_gt = GT_POSES[label]['R']
    t_gt = GT_POSES[label]['t']

    # Translation error (mm)
    t_err = np.linalg.norm(t_est - t_gt) * 1000.0

    # Rotation error (deg, symmetry-aware)
    r_err = rotation_error(R_est, R_gt, label)

    results[label] = (t_err, r_err)

# -------------------------------------------------------------------
# Print results
# -------------------------------------------------------------------
print("Pose Errors (translation [mm], rotation [deg]) with symmetry:")
for obj, (terr, rerr) in results.items():
    print(f"{obj:6s}  t_err = {terr:7.2f} mm   r_err = {rerr:6.2f}°")
